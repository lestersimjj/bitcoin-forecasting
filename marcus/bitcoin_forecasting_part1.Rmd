---
title: "Bitcoin Forecasting"
---

**Currently these are the additional features added: (updated as of 30/11)**

* **Sentiment**
1. News Articles
2. If want to use reddit posts: can consider using <code>library(RedditExtractoR)</code> and <code>get_reddit(...)</code>
3. If want to use Twitter (i can only think of using python <code>twint</code> which does not need API to scrape the tweets)

* **Technical**
Comments: 
* I think some of the indicators might measure the same thing? Do help to remove any if its not a necessary feature.
* Not sure if can combine say e.g. 2 different indicators into 1 indicator as a feature?

1. Bollinger Band Width
2. RSI
3. MACD
4. Accumulation/Distribution Indicator
5. EMA (12,24,72 days)
6. SMA (12,24,72 days)
7. Rate of Change (it was mentioned that this can be combined with other indicators e.g. moving averages or stochastic to provide a better analysis?)
8. On-Balance Volume
9. Network Value to Transactions (NVT) - something similar to "P/E ratio"
10. Average True Range (ATR) - measures volatility


* **Others**
1. Fed Fund Rates
2. S&P500 Closing Price
3. Gold (XAU/USD)
A paper uses the following below: [Link](https://arxiv.org/ftp/arxiv/papers/1706/1706.01437.pdf)
4. Financial stress index
5. AAII Sentiment - Is a weekly data, but since the bitcoin price is daily, i just fill the days with the week data, not sure if that's ok?
7. CNY/USD 


# **Load Packages**
```{r,echo=FALSE, collapse=TRUE, message=FALSE}
options(scipen = 99)
library(dplyr)
library(tidyverse)
library(stringr)
library(almanac)
library(lubridate)
library(Quandl)
library(gtrendsR)
library(RcppRoll)
library(xgboost)
library(MLmetrics)
library(pageviews)
library(quantmod)
library("doFuture"); registerDoFuture(); plan(multiprocess)
library(tidyquant)
library(tidymodels)
library(tsfeatures)
library(slider)
library(timetk)
library(data.table)
library(grid)
library(plotly) #for candlestick plot
library(hablar) #for bollinger band analysis

```

# **Scrape/Download Data**

## **Additional Features added (to consider)**
### **Import the scrapped Bitcoin News Articles - Sentiments**

* This is included because I feel that on top of technical analysis, sentiment analysis is also equally important. Although there is scraping of google hits, sentiments gathered from news articles can also be a possible feature to consider. This is because it can give us a general idea of people's opinions and sentiments about Bitcoin, which may be an equally good indicator as to how frequent people search bitcoin on the search engine.

* This is to see if a positive/negative news will affect the next day or current day price of Bitcoin. The idea is to monitor the public mood about the Bitcoin market or perhaps if the Bitcoin prices will be affected by certain new regulations introduced. We can then see if there is any correlation between the sentiment and the closing price of bitcoin, and hopefully will add value to the model we are building to predict future prices of Bitcoin and give a recommendation if it is the right time to enter and buy Bitcoin.

* Disclaimer and limitations in the news articles scrapped are mentioned in the 'Bitcoin News Analytics' RMarkdown.
* The websites where the scrapping of news articles are done are also mentioned in that RMarkdown. 2 news site are used, though there may be concerns about the biasness of articles because it is taken from Bitcoin related websites, but results shown there are mixed sentiments on Bitcoin from the articles on those 2 websites chosen. There is no clear swayness towards positivity on Bitcoin.

```{r}
news_articles_sentiments_bing <- read.csv("bitcoin_sentiment_bing.csv")
news_articles_sentiments_bing <- news_articles_sentiments_bing[-c(1)] # drop first column

news_articles_sentiments_afinn <- read.csv("bitcoin_sentiment_afinn.csv")
news_articles_sentiments_afinn <- news_articles_sentiments_afinn[-c(1)] # drop first column

news_articles_sentiments_sentimentr <- read.csv("bitcoin_sentiment_sentimentr.csv")
news_articles_sentiments_sentimentr <- news_articles_sentiments_sentimentr[-c(1)] # drop first column

```

## **Federal Funds Rate**

* Besides all the data that's scrapped, a research paper [#insert ref] has revealed that Federal Funds Rate is a possible influence on Bitcoin prices. FFR is the target interest rate set by the FOMC at which commercial banks borrow and lend their excess reserves to each other overnight. FOMC sets a target federal funds rate eight times a year, based on prevailing economic conditions.

* As an investment asset, the US Federal Reserve’s Interest Rate Policy can have certain impact on Bitcoin price. Increase in the FFR may have adverse impact on Bitcoin price based on the following two assumptions: rise in US dollar and reduce in speculative investments. 
  + First, the US dollar will benefit from the rate increase because raising interest rates may lead to capital flow back to the US market therefore cause Bitcoin price fell. 
  + Second, increase in interest rate could reduce speculative investments. 
* The data was downloaded from <a href="https://fred.stlouisfed.org/series/EFFR" target="_blank">this site</a>
  
```{r}
fedfundsrate <- read.csv("fedfundsrate.csv")
fedfundsrate$DATE <- as.Date(fedfundsrate$DATE)
fedfundsrate <- subset(fedfundsrate, DATE>=as.Date("2011-09-13"))
colnames(fedfundsrate) <- c("date", "effr")
fedfundsrate$effr[fedfundsrate$effr=="."] <- NA
fedfundsrate <- fedfundsrate %>% map_df(na.locf)
fedfundsrate$effr <- as.numeric(fedfundsrate$effr)

```

## **Gold Price**
* XAU/USD

```{r}
xau_usd_historical$Date <- as.Date(xau_usd_historical$Date, format="%B %d, %Y")
xau_usd_df <- select(xau_usd_historical,c(Date,Price))
colnames(xau_usd_df) <- c("date","price")

```


# **Feature Engineering**

## BITCOIN PRICE DATA

```{r}
# The quandl_tidy function is a wrapper around the Quandl function that returns a cleaner tibble.  
Quandl.api_key("s6CuJx8yVodVwU-ymz_5")
quandl_tidy <- function(code, name) { 
  df <- Quandl(code) %>% 
    mutate(code = code, name = name) %>% 
    rename(date = Date, value = Value) %>% 
    arrange(date) %>% 
    as_tibble()
  return(df)
}

bitcoin_price <- Quandl("BCHARTS/BITSTAMPUSD") %>% 
  arrange(Date) %>% 
  as_tibble()

colnames(bitcoin_price) <- c("date", "open", "high", "low", "close", "volume_btc", "volume_currency", "weighted_price")

```

### Cleaning Bitcoin Prices
```{r}
bitcoin_price[bitcoin_price == 0] <- NA
bitcoin_price <- bitcoin_price %>% map_df(na.locf)

```

### Define Target

* The future return was changed to **log returns** instead of arithmetic returns. Arithmetic return has a positive bias. To eliminate this bias a log return is preferred. It removes this bias and puts all the numbers in a log plane, and in the process also normalizing the returns to log normal. 

```{r}
bitcoin_model <- bitcoin_price %>%
  tq_mutate(select = close,
            mutate_fun = periodReturn,
            period = 'daily',
            type = 'log',                            
            col_rename = 'future_return') %>%
  mutate(future_return_sign = as.factor(ifelse(future_return > 0, 1, 0)),
         close = lag(close, 1),
         date = date - days(1)) %>%
  select(date, close, future_return, future_return_sign) 

bitcoin_model <- bitcoin_model[-1, ]

```

## **Additional Features added (to consider)**

### **Bollinger Bands**

* The two main goals of this indicator are to convey the market message on the volatility and to define high (resistance) or low (support) on a relative basis. 
* If the price action hits the upper Bollinger Band, the tool suggests that the asset is overbought and that we may see a rotation from the current levels.
* Bollinger Bands are a price-performance forecasting model revolving around the 20-day simple moving average (SMA) of an asset. The SMA has an upper and lower band around it, which analysts plot using standard deviation.
* As volatility increases, so the bands become further apart. In times of low volatility, the bands contract, or “squeeze.”
* When the two outer lines are contracting and narrowing down, the volatility is lower, which usually means that the market is ranging and consolidating – the so-called “Bollinger Band squeeze”.
* A sharp change in the market behavior is likely to lead towards the squeeze breakout. 

```{r}
# create Bollinger Bands
bitcoin_price_data <- bitcoin_price
library(hablar)
bitcoin_price_data <- bitcoin_price_data %>% 
  convert(num(open:weighted_price))
bbands <- BBands(bitcoin_price_data[,c("high","low","close")]) #dn - The lower bollinger band, mavg - middle moving average, up - the upper bollinger band

# join and subset data
date_band <- "2011-09-13"
df_1 <- subset(cbind(bitcoin_price, data.frame(bbands[,1:3])), date >= date_band)
row.names(df_1) <- NULL

```

```{r}
# Find Bollinger Band Width
# Band Width = (Upper Bollinger Band - Lower Bollinger Band) / Middle Bollinger Band
# According to John Bollinger, the fall in the Bollinger Bandwidth indicator below 2% or 0.02 has led to big moves in the S&P500 index. Let's see if there is any similarity to the Bitcoin market.
# if the width becomes narrower, it indicates that it will expands next which signals buy
df_1 <- df_1 %>% mutate(bb_width = (up-dn)/mavg)

#Another way:
#When %B is above 1, price is above the upper band and when %B is below 0, price is below the lower band.
# %B used to quantify the distance between price and the upper or lower band.
df_1 <- df_1 %>% mutate(bb_percent_b = (close-dn)/(up-dn))


```

```{r}
bb_df <- df_1 %>% select(c(date,bb_width,bb_percent_b))
bitcoin_model <- bitcoin_model %>% left_join(bb_df)

```


## **Relative Strength Index (RSI)**

* RSI is a momentum oscillator that measures the speed and change of price movements. 
* It oscillates between zero and 100. 
* According to Wilder, RSI is considered overbought when > 70 and oversold when < 30.

```{r}
bitcoin_model_date <- as.data.frame(bitcoin_model$date)
rsi <- as.data.frame(RSI(bitcoin_model$close,14))
rsi <- cbind(bitcoin_model_date,rsi)
colnames(rsi) <- c("date","rsi")
bitcoin_model <- bitcoin_model %>% left_join(rsi)

```

## **MACD (Moving Average Convergence/Divergence)**
* Buy signal arises when MACD crosses from below to above the signal line. (bullish signal) - price of the bitcoin is likely to experience upward momentum
* Sell signal arises when MACD crosses from above to below the signal line. (bearish signal)

```{r}
# Usually, K = 9 days,  S = 12 days and L = 26 days

myMACD <- function (x,price,S,L,K){
  MACD <- EMA(price,S) - EMA(price,L)
  signal <- EMA(MACD,K)
  date <- x[,1]
  price <- price
  output <- cbind(date,price, MACD,signal)
  colnames(output) <- c("date","closing_price", "MACD","signal")
  return(output)
}

macd <- myMACD(bitcoin_price,Cl(bitcoin_price), 12, 26,9)
tail(macd,n=5)

macd <- macd %>% mutate(macd_signal_dist = MACD-signal)

```

```{r}
# Since it was mentioned that traders use the MACD’s histogram to identify when bullish or bearish momentum is high, so we will only extract the distance calculated (MACD-signal) column to add into the bitcoin model.
macd_df <- macd %>% select(c(date,macd_signal_dist))
bitcoin_model <- bitcoin_model %>% left_join(macd_df)

```

## **Accumulation/Distribution Indicator**

* The accumulation/distribution measure seeks to identify divergences between the stock price and volume flow. 
* This provides insight into how strong a trend is. 
* If the price is rising but the indicator is falling this indicates that buying or accumulation volume may not be enough to support the price rise and a price decline could be forthcoming.
* A rising A/D line helps confirm a rising price trend.
* A falling A/D line helps confirm a price downtrend.
* If the price is rising but A/D is falling, it signals underlying weakness and a potential decline in price.
* If the price of an asset is falling but A/D is rising, it signals underlying strength and the price may start to rise.

```{r}
acu_dis_df <- bitcoin_price
acu_dis_df <- acu_dis_df %>% mutate(cmfv = ((bitcoin_price$close-bitcoin_price$low)-(bitcoin_price$high-bitcoin_price$close))/(bitcoin_price$high-bitcoin_price$low)*bitcoin_price$volume_currency)
acu_dis_df$cmfv[is.na(acu_dis_df$cmfv)] <- 0
acu_dis_df <- acu_dis_df %>% mutate(cumulative_cmfv = cumsum(cmfv))

```

```{r}

acu_dis_df_add <- acu_dis_df %>% select(date,cumulative_cmfv)
bitcoin_model <- bitcoin_model %>% left_join(acu_dis_df_add)

```

## **Bitcoin News Sentiments**

```{r}
# "bing"
colnames(news_articles_sentiments_bing) <- c("date","positive_sentiment_bing")
news_articles_sentiments_bing$date <- as.Date(news_articles_sentiments_bing$date)
bitcoin_model <- bitcoin_model %>% 
  left_join(news_articles_sentiments_bing)

# "Afinn"
colnames(news_articles_sentiments_afinn) <- c("date","positive_sentiment_afinn")
news_articles_sentiments_afinn$date <- as.Date(news_articles_sentiments_afinn$date)
bitcoin_model <- bitcoin_model %>% 
  left_join(news_articles_sentiments_afinn)

```

```{r}
#Using sentimentr

news_articles_sentiments_sentimentr_extract <- select(news_articles_sentiments_sentimentr,c(article_date,ave_sentiment))
news_articles_sentiments_sentimentr_extract <- news_articles_sentiments_sentimentr_extract %>%
  mutate(positive_sentiment_sentimentr = ifelse(ave_sentiment>0,1,0))
news_articles_sentiments_sentimentr_extract  <- select(news_articles_sentiments_sentimentr_extract, c(article_date,positive_sentiment_sentimentr))
setnames(news_articles_sentiments_sentimentr_extract, "article_date", "date")
news_articles_sentiments_sentimentr_extract$date <- as.Date(news_articles_sentiments_sentimentr_extract$date)
bitcoin_model <- bitcoin_model %>% 
  left_join(news_articles_sentiments_sentimentr_extract)

```


## **Fed Funds Rate**

```{r}
bitcoin_model <- bitcoin_model %>% left_join(fedfundsrate)
bitcoin_model <- bitcoin_model %>% fill(effr,.direction = "down")

```

## **S&P500 Closing Price**
```{r}
get_yahoo <- function(ticker) {
  
  df <- getSymbols(ticker, src = 'yahoo', auto.assign = FALSE, from = '1900-01-01')
  
  df <- df %>%
    as_tibble() %>%
    mutate(date = index(df))
  
  colnames(df) <- c("open", "high", "low", "close", "volume", "adjusted_close", "date", "ticker")
  
  return(df)
  
}

sp500 <- get_yahoo('^GSPC') %>%
  select(date, sp500 = close)
bitcoin_model <- bitcoin_model %>% left_join(sp500)
# fill na downwards for weekend missing values - fill with fri closing price
bitcoin_model <- bitcoin_model %>% fill(sp500, .direction = "down")

```


## **EMA**

Reference - Article Technical Analysis on the Bitcoin Market: Trading Opportunities or Investors’ Pitfall?

```{r}
# 12-days EMA, 24-days EMA, 72-days EMA

bitcoin_date <- as.data.frame(bitcoin_price$date)
colnames(bitcoin_date) <- c("date")

bitcoin_ema <- list()
range_ema <- c(12,24,72)
for (i in seq_along(range_ema)){
  bitcoin_ema_v <- EMA(Cl(bitcoin_price),n=i)
  bitcoin_ema[[i]] <- bitcoin_ema_v
}

bitcoin_ema <- as.data.frame(do.call(cbind, bitcoin_ema)) 
names_ema <- c(paste0("ema_", range_ema)) %>% strsplit(split = " ")
colnames(bitcoin_ema) <- names_ema
ema <- bitcoin_date %>% cbind(bitcoin_ema)

bitcoin_model <- bitcoin_model %>% left_join(ema)

# EMA: More weightage placed on recent price levels rather than past ones compared to using SMA
```

## **SMA**

```{r}
# 12-days SMA, 24-days SMA, 72-days SMA

bitcoin_sma <- list()
range_sma <- c(12,24,72)
for (i in seq_along(range_sma)){
  bitcoin_sma_v <- SMA(Cl(bitcoin_price),n=i)
  bitcoin_sma[[i]] <- bitcoin_sma_v
}

bitcoin_sma <- as.data.frame(do.call(cbind, bitcoin_sma)) 
names_sma <- c(paste0("sma_", range_sma)) %>% strsplit(split = " ")
colnames(bitcoin_sma) <- names_sma
sma <- bitcoin_date %>% cbind(bitcoin_sma)

bitcoin_model <- bitcoin_model %>% left_join(sma)

```


## **Rate of Change**

The n value is how many periods ago the current price is being compared to. Smaller values will see the ROC react more quickly to price changes, but that can also mean more false signals. A larger value means the ROC will react slower, but the signals could be more meaningful when they occur.
Short-term trader traders typically use a smaller number while longer-term investors use a larger number.

```{r}
# Assumptions:
# short term: 14,28
# longer term: 90,180,200

bitcoin_roc <- list()
range_roc <- c(14,28,90,180,200)
for (i in seq_along(range_roc)){
  bitcoin_roc_v <- ROC(Cl(bitcoin_price),n=i)
  bitcoin_roc[[i]] <- bitcoin_roc_v
}

bitcoin_roc <- as.data.frame(do.call(cbind, bitcoin_roc)) 
names_roc <- c(paste0("roc_", range_roc)) %>% strsplit(split = " ")
colnames(bitcoin_roc) <- names_roc

bitcoin_roc <- bitcoin_date %>% cbind(bitcoin_roc)

bitcoin_model <- bitcoin_model %>% left_join(bitcoin_roc)

```

## **On-Balance Volume**
On-balance volume and the accumulation/distribution line are similar in that they are both momentum indicators that use volume to predict the movement of “smart money”. 
```{r}
bitcoin_obv <- as.data.frame(OBV(bitcoin_price$close, bitcoin_price$volume_currency))
bitcoin_obv <- bitcoin_date %>% cbind(bitcoin_obv)
colnames(bitcoin_obv) <- c("date","on_balance_vol")

bitcoin_model <- bitcoin_model %>% left_join(bitcoin_obv)

```

### **NVT Ratio**
NVT Ratio (Network Value to Transactions Ratio) is similar to the PE Ratio used in equity markets.

Similar to the price-to-earnings (PE) ratio used in equity charts, the NVT looks at whether BTC is undervalued or overvalued. The ratio represents current market capitalization via network value and the level of USD-based transaction volume over a 24-hour period.

High NVT can indicate high growth or that the price may have reached an unsustainable level, while low NVT can signal market opportunity. 

Using the bitcoin indicators data to do this calculation. It takes Bitcoin Market Capitalization/Bitcoin Estimated Transaction Volume USD
```{r}
# Data about bitcoin activity, transaction fees, and mining. 
print("Downloading bitcoin indicators.")
code_list <- list(c("BCHAIN/TOTBC", "Total Bitcoins"), 
                  c("BCHAIN/MKTCP", "Bitcoin Market Capitalization"), 
                  c("BCHAIN/NADDU", "Bitcoin Number of Unique Addresses Used"), 
                  c("BCHAIN/ETRAV", "Bitcoin Estimated Transaction Volume BTC"), 
                  c("BCHAIN/ETRVU", "Bitcoin Estimated Transaction Volume USD"), 
                  c("BCHAIN/TRVOU", "Bitcoin USD Exchange Trade Volume"), 
                  c("BCHAIN/NTRAN", "Bitcoin Number of Transactions"), 
                  c("BCHAIN/NTRAT", "Bitcoin Total Number of Transactions"), 
                  c("BCHAIN/NTREP", "Bitcoin Number of Transactions Excluding Popular Addresses"), 
                  c("BCHAIN/NTRBL", "Bitcoin Number of Tansaction per Block"), 
                  c("BCHAIN/ATRCT", "Bitcoin Median Transaction Confirmation Time"), 
                  c("BCHAIN/TRFEE", "Bitcoin Total Transaction Fees"), 
                  c("BCHAIN/TRFUS", "Bitcoin Total Transaction Fees USD"), 
                  c("BCHAIN/CPTRA", "Bitcoin Cost Per Transaction"), 
                  c("BCHAIN/CPTRV", "Bitcoin Cost % of Transaction Volume"), 
                  c("BCHAIN/BLCHS", "Bitcoin api.blockchain Size"), 
                  c("BCHAIN/AVBLS", "Bitcoin Average Block Size"), 
                  c("BCHAIN/TOUTV", "Bitcoin Total Output Volume"), 
                  c("BCHAIN/HRATE", "Bitcoin Hash Rate"), 
                  c("BCHAIN/MIREV", "Bitcoin Miners Revenue"), 
                  c("BCHAIN/BCDDE", "Bitcoin Days Destroyed"), 
                  c("BCHAIN/BCDDW", "Bitcoin Days Destroyed Minimum Age 1 Week"), 
                  c("BCHAIN/BCDDM", "Bitcoin Days Destroyed Minimum Age 1 Month"), 
                  c("BCHAIN/BCDDY", "Bitcoin Days Destroyed Minimum Age 1 Year") ,
                  c("BCHAIN/BCDDC", "Bitcoin Days Destroyed Cumulative"))

bitcoin_data <- tibble()
# bitcoin_data <- foreach(i=seq_along(code_list), .combine='bind_rows') %dopar% {quandl_tidy(code_list[[i]][1], code_list[[i]][2])}
for (i in seq_along(code_list)) { 
  print(str_c("Downloading data for ", code_list[[i]][1], "."))
  bitcoin_data <- bind_rows(bitcoin_data, 
                            quandl_tidy(code_list[[i]][1], code_list[[i]][2]))
}

```

```{r}
# Clean Bitcoin Indicators
bitcoin_data <- bitcoin_data %>% 
  select(date, value, code) %>% 
  spread(code, value)
colnames(bitcoin_data) <- make.names(colnames(bitcoin_data))
names(bitcoin_data) <- tolower(names(bitcoin_data))

```

```{r}
# NVT
bitcoin_data$nvt <- bitcoin_data$bchain.mktcp/bitcoin_data$bchain.etrvu
bitcoin_data_nvt <- select(bitcoin_data,c(date,nvt))

bitcoin_model <- bitcoin_model %>% left_join(bitcoin_data_nvt)
```

## **Average True Range (ATR)**

* a common indicator designed to measure volatility
* neither indicates trend direction nor momentum --> so need other indicators to do that instead
* experiencing a high level of volatility has a higher ATR, and a low volatility stock has a lower
```{r}

atr <- ATR(bitcoin_price[,c("high","low","close")], n=14) #14-days moving average
atr <- bitcoin_date %>% cbind(atr)
atr <- select(atr,c(date,atr))

bitcoin_model <- bitcoin_model %>% left_join(atr)
```

## **Financial stress index**

https://www.financialresearch.gov/financial-stress-index/

* The OFR Financial Stress Index (OFR FSI) is a daily market-based snapshot of stress in global financial markets. It is constructed from 33 financial market variables, such as yield spreads, valuation measures, and interest rates. The OFR FSI is positive when stress levels are above average, and negative when stress levels are below average.

* The OFR FSI incorporates five categories of indicators: credit, equity valuation, funding, safe assets and volatility. The FSI shows stress contributions by three regions: United States, other advanced economies, and emerging markets. The value of the OFR FSI on a given day is the weighted average level of each variable observed in the market on that day, relative to its history. The index is zero when this average is zero, suggesting that stress is at normal levels. The index is calculated after each U.S. trading day.

```{r}
# use the FSI data from the csv
fsi_df <- fsi %>% select(date="Date", ofr_fsi = "OFR FSI")
fsi_df$date <- as.Date(fsi_df$date)
                             
bitcoin_model <- bitcoin_model %>% left_join(fsi_df)

#weekend missing, fill by fri's numbers
bitcoin_model <- bitcoin_model %>% fill(ofr_fsi,.direction = "down")

```

## **AAII Sentiment**
* The AAII Investor Sentiment Survey measures the percentage of individual investors who are bullish, bearish, and neutral on the stock market for the next six months; individuals are polled from the ranks of the AAII membership on a weekly basis. Only one vote per member is accepted in each weekly voting period.

* Since this AAII sentiment (comprises bullish, neutral and bearish sentiment) is for stock market, we take the assumption that bitcoin is seen as a "safe haven" compared to stock, so we will take the bearish sentiment.

```{r}
# The quandl_tidy function is a wrapper around the Quandl function that returns a cleaner tibble.  
Quandl.api_key("s6CuJx8yVodVwU-ymz_5")

aaii_sentiment <- Quandl("AAII/AAII_SENTIMENT") %>% 
  arrange(Date) %>% 
  as_tibble()

aaii_sentiment_df <- aaii_sentiment %>% select(date="Date", aaii_bearish_sentiment = "Bearish")

bitcoin_model <- bitcoin_model %>% left_join(aaii_sentiment_df)

bitcoin_model <- bitcoin_model %>% fill(aaii_bearish_sentiment,.direction = "up")

```

## **CNY/USD**
* Bitcoin is mostly traded in China [Reference](https://www.businessinsider.com/bitcoin-trading-china-yuan-remnibi-2017-1)
* Chinese mining pools control more than 60% of the Bitcoin network’s collective hashrate [Reference](https://news.bitcoin.com/65-of-global-bitcoin-hashrate-concentrated-in-china/) and one-third of global hash rate is in Xinjiang.  [Reference](https://cointelegraph.com/news/a-single-chinese-region-accounts-for-one-third-of-global-btc-hash-rate)
* So it might be worthwhile to account for movements in the exchanges between the dollar with the yuan 

```{r}
cny_usd <- get_yahoo('USDCNY=X') %>%
  select(date, cny_usd_close = close)
bitcoin_model <- bitcoin_model %>% left_join(cny_usd)

# fill na downwards for weekend missing values - fill with fri closing price
bitcoin_model <- bitcoin_model %>% fill(cny_usd_close, .direction = "down")
```

# **Predictive Modelling**

Using data from 2013 Oct onwards
```{r}
bitcoin_model <- bitcoin_model %>% filter(date >= '2013-10-01')
```

