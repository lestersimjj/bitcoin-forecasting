---
title: "Bitcoin Forecasting"
author: "Marcus Cheong Wei Ze"
date: "21/11/2020"
output: 
---

**Currently these are the additional features added: (updated as of 29/11)**

* **Sentiment**
1. News Articles
2. If want to use reddit posts: can consider using <code>library(RedditExtractoR)</code> and <code>get_reddit(...)</code>


* **Technical**
Comments: 
* I think some of the indicators might measure the same thing? Do help to remove any if its not a necessary feature.
* Not sure if can combine say e.g. 2 different indicators into 1 indicator as a feature?

1. Bollinger Band Width
2. RSI
3. MACD
4. Accumulation/Distribution Indicator
5. EMA (12,24,72 days)
6. SMA (12,24,72 days)
7. Rate of Change (it was mentioned that this can be combined with other indicators e.g. moving averages or stochastic to provide a better analysis?)
8. On-Balance Volume
9. Network Value to Transactions (NVT) - something similar to "P/E ratio"
10. Average True Range (ATR)


* **Others**
1. Fed Fund Rates
2. S&P500 Closing Price
3. Gold? (haven't add in, not sure)


# **Load Packages**
```{r,echo=FALSE, collapse=TRUE, message=FALSE}
options(scipen = 99)
library(dplyr)
library(tidyverse)
library(stringr)
library(almanac)
library(lubridate)
library(Quandl)
library(gtrendsR)
library(RcppRoll)
library(xgboost)
library(MLmetrics)
library(pageviews)
library(quantmod)
library("doFuture"); registerDoFuture(); plan(multiprocess)
library(tidyquant)
library(tidymodels)
library(tsfeatures)
library(slider)
library(timetk)
library(data.table)
library(grid)
library(plotly) #for candlestick plot
library(hablar) #for bollinger band analysis

```

# **Scrape/Download Data**

## **Additional Features added (to consider)**
### **Import the scrapped Bitcoin News Articles - Sentiments**

* This is included because I feel that on top of technical analysis, sentiment analysis is also equally important. Although there is scraping of google hits, sentiments gathered from news articles can also be a possible feature to consider. This is because it can give us a general idea of people's opinions and sentiments about Bitcoin, which may be an equally good indicator as to how frequent people search bitcoin on the search engine.

* This is to see if a positive/negative news will affect the next day or current day price of Bitcoin. The idea is to monitor the public mood about the Bitcoin market or perhaps if the Bitcoin prices will be affected by certain new regulations introduced. We can then see if there is any correlation between the sentiment and the closing price of bitcoin, and hopefully will add value to the model we are building to predict future prices of Bitcoin and give a recommendation if it is the right time to enter and buy Bitcoin.

* Disclaimer and limitations in the news articles scrapped are mentioned in the 'Bitcoin News Analytics' RMarkdown.
* The websites where the scrapping of news articles are done are also mentioned in that RMarkdown. 2 news site are used, though there may be concerns about the biasness of articles because it is taken from Bitcoin related websites, but results shown there are mixed sentiments on Bitcoin from the articles on those 2 websites chosen. There is no clear swayness towards positivity on Bitcoin.

```{r}
news_articles_sentiments_bing <- read.csv("bitcoin_sentiment_bing.csv")
news_articles_sentiments_bing <- news_articles_sentiments_bing[-c(1)] # drop first column

news_articles_sentiments_afinn <- read.csv("bitcoin_sentiment_afinn.csv")
news_articles_sentiments_afinn <- news_articles_sentiments_afinn[-c(1)] # drop first column

news_articles_sentiments_sentimentr <- read.csv("bitcoin_sentiment_sentimentr.csv")
news_articles_sentiments_sentimentr <- news_articles_sentiments_sentimentr[-c(1)] # drop first column

```

## **Federal Funds Rate**

* Besides all the data that's scrapped, a research paper [#insert ref] has revealed that Federal Funds Rate is a possible influence on Bitcoin prices. FFR is the target interest rate set by the FOMC at which commercial banks borrow and lend their excess reserves to each other overnight. FOMC sets a target federal funds rate eight times a year, based on prevailing economic conditions.

* As an investment asset, the US Federal Reserve’s Interest Rate Policy can have certain impact on Bitcoin price. Increase in the FFR may have adverse impact on Bitcoin price based on the following two assumptions: rise in US dollar and reduce in speculative investments. 
  + First, the US dollar will benefit from the rate increase because raising interest rates may lead to capital flow back to the US market therefore cause Bitcoin price fell. 
  + Second, increase in interest rate could reduce speculative investments. 
* The data was downloaded from <a href="https://fred.stlouisfed.org/series/EFFR" target="_blank">this site</a>
  
```{r}
fedfundsrate <- read.csv("fedfundsrate.csv")
fedfundsrate$DATE <- as.Date(fedfundsrate$DATE)
fedfundsrate <- subset(fedfundsrate, DATE>=as.Date("2011-09-13"))
colnames(fedfundsrate) <- c("date", "effr")
fedfundsrate$effr[fedfundsrate$effr=="."] <- NA
fedfundsrate <- fedfundsrate %>% map_df(na.locf)
fedfundsrate$effr <- as.numeric(fedfundsrate$effr)

```

# **Feature Engineering**

## BITCOIN PRICE DATA

### Cleaning Bitcoin Prices
```{r}
bitcoin_price[bitcoin_price == 0] <- NA
bitcoin_price <- bitcoin_price %>% map_df(na.locf)

```

### Define Target

* The future return was changed to **log returns** instead of arithmetic returns. Arithmetic return has a positive bias. To eliminate this bias a log return is preferred. It removes this bias and puts all the numbers in a log plane, and in the process also normalizing the returns to log normal. 

```{r}
bitcoin_model <- bitcoin_price %>%
  tq_mutate(select = close,
            mutate_fun = periodReturn,
            period = 'daily',
            type = 'log',                            
            col_rename = 'future_return') %>%
  mutate(future_return_sign = as.factor(ifelse(future_return > 0, 1, 0)),
         close = lag(close, 1),
         date = date - days(1)) %>%
  select(date, close, future_return, future_return_sign) 

bitcoin_model <- bitcoin_model[-1, ]

```

## **Additional Features added (to consider)**

### **Bollinger Bands**

* The two main goals of this indicator are to convey the market message on the volatility and to define high (resistance) or low (support) on a relative basis. 
* If the price action hits the upper Bollinger Band, the tool suggests that the asset is overbought and that we may see a rotation from the current levels.
* Bollinger Bands are a price-performance forecasting model revolving around the 20-day simple moving average (SMA) of an asset. The SMA has an upper and lower band around it, which analysts plot using standard deviation.
* As volatility increases, so the bands become further apart. In times of low volatility, the bands contract, or “squeeze.”
* When the two outer lines are contracting and narrowing down, the volatility is lower, which usually means that the market is ranging and consolidating – the so-called “Bollinger Band squeeze”.
* A sharp change in the market behavior is likely to lead towards the squeeze breakout. 

```{r}
# create Bollinger Bands
bitcoin_price_data <- bitcoin_price
library(hablar)
bitcoin_price_data <- bitcoin_price_data %>% 
  convert(num(open:weighted_price))
bbands <- BBands(bitcoin_price_data[,c("high","low","close")]) #dn - The lower bollinger band, mavg - middle moving average, up - the upper bollinger band

# join and subset data
date_band <- "2011-09-13"
df_1 <- subset(cbind(bitcoin_price, data.frame(bbands[,1:3])), date >= date_band)
row.names(df_1) <- NULL

```

```{r}
# Find Bollinger Band Width
# Band Width = (Upper Bollinger Band - Lower Bollinger Band) / Middle Bollinger Band
# According to John Bollinger, the fall in the Bollinger Bandwidth indicator below 2% or 0.02 has led to big moves in the S&P500 index. Let's see if there is any similarity to the Bitcoin market.
# if the width becomes narrower, it indicates that it will expands next which signals buy
df_1 <- df_1 %>% mutate(bb_width = (up-dn)/mavg)

```

```{r}
bb_df <- df_1 %>% select(c(date,bb_width))
bitcoin_model <- bitcoin_model %>% left_join(bb_df)

```


## **Relative Strength Index (RSI)**

* RSI is a momentum oscillator that measures the speed and change of price movements. 
* It oscillates between zero and 100. 
* According to Wilder, RSI is considered overbought when > 70 and oversold when < 30.

```{r}
bitcoin_model_date <- as.data.frame(bitcoin_model$date)
rsi <- as.data.frame(RSI(bitcoin_model$close,14))
rsi <- cbind(bitcoin_model_date,rsi)
colnames(rsi) <- c("date","rsi")
bitcoin_model <- bitcoin_model %>% left_join(rsi)

```

## **MACD (Moving Average Convergence/Divergence)**
* Buy signal arises when MACD crosses from below to above the signal line. (bullish signal) - price of the bitcoin is likely to experience upward momentum
* Sell signal arises when MACD crosses from above to below the signal line. (bearish signal)

```{r}
# Usually, K = 9 days,  S = 12 days and L = 26 days

myMACD <- function (x,price,S,L,K){
  MACD <- EMA(price,S) - EMA(price,L)
  signal <- EMA(MACD,K)
  date <- x[,1]
  price <- price
  output <- cbind(date,price, MACD,signal)
  colnames(output) <- c("date","closing_price", "MACD","signal")
  return(output)
}

macd <- myMACD(bitcoin_price,Cl(bitcoin_price), 12, 26,9)
tail(macd,n=5)

macd <- macd %>% mutate(macd_signal_dist = MACD-signal)

```

```{r}
# Since it was mentioned that traders use the MACD’s histogram to identify when bullish or bearish momentum is high, so we will only extract the distance calculated (MACD-signal) column to add into the bitcoin model.
macd_df <- macd %>% select(c(date,macd_signal_dist))
bitcoin_model <- bitcoin_model %>% left_join(macd_df)

```

## **Accumulation/Distribution Indicator**

* The accumulation/distribution measure seeks to identify divergences between the stock price and volume flow. 
* This provides insight into how strong a trend is. 
* If the price is rising but the indicator is falling this indicates that buying or accumulation volume may not be enough to support the price rise and a price decline could be forthcoming.
* A rising A/D line helps confirm a rising price trend.
* A falling A/D line helps confirm a price downtrend.
* If the price is rising but A/D is falling, it signals underlying weakness and a potential decline in price.
* If the price of an asset is falling but A/D is rising, it signals underlying strength and the price may start to rise.

```{r}
acu_dis_df <- bitcoin_price
acu_dis_df <- acu_dis_df %>% mutate(cmfv = ((bitcoin_price$close-bitcoin_price$low)-(bitcoin_price$high-bitcoin_price$close))/(bitcoin_price$high-bitcoin_price$low)*bitcoin_price$volume_currency)
acu_dis_df$cmfv[is.na(acu_dis_df$cmfv)] <- 0
acu_dis_df <- acu_dis_df %>% mutate(cumulative_cmfv = cumsum(cmfv))

```

```{r}

acu_dis_df_add <- acu_dis_df %>% select(date,cumulative_cmfv)
bitcoin_model <- bitcoin_model %>% left_join(acu_dis_df_add)

```

## **Bitcoin News Sentiments**

```{r}
# "bing"
colnames(news_articles_sentiments_bing) <- c("date","positive_sentiment_bing")
news_articles_sentiments_bing$date <- as.Date(news_articles_sentiments_bing$date)
bitcoin_model <- bitcoin_model %>% 
  left_join(news_articles_sentiments_bing)

# "Afinn"
colnames(news_articles_sentiments_afinn) <- c("date","positive_sentiment_afinn")
news_articles_sentiments_afinn$date <- as.Date(news_articles_sentiments_afinn$date)
bitcoin_model <- bitcoin_model %>% 
  left_join(news_articles_sentiments_afinn)

```

```{r}
#Using sentimentr

news_articles_sentiments_sentimentr_extract <- select(news_articles_sentiments_sentimentr,c(article_date,ave_sentiment))
news_articles_sentiments_sentimentr_extract <- news_articles_sentiments_sentimentr_extract %>%
  mutate(positive_sentiment_sentimentr = ifelse(ave_sentiment>0,1,0))
news_articles_sentiments_sentimentr_extract  <- select(news_articles_sentiments_sentimentr_extract, c(article_date,positive_sentiment_sentimentr))
setnames(news_articles_sentiments_sentimentr_extract, "article_date", "date")
news_articles_sentiments_sentimentr_extract$date <- as.Date(news_articles_sentiments_sentimentr_extract$date)
bitcoin_model <- bitcoin_model %>% 
  left_join(news_articles_sentiments_sentimentr_extract)

```


## **Fed Funds Rate**

```{r}
bitcoin_model <- bitcoin_model %>% left_join(fedfundsrate)
bitcoin_model <- bitcoin_model %>% fill(effr,.direction = "down")

```

## **S&P500 Closing Price**
```{r}
sp500 <- get_yahoo('^GSPC') %>%
  select(date, sp500 = close)
bitcoin_model <- bitcoin_model %>% left_join(sp500)

```


## **EMA**

Reference - Article Technical Analysis on the Bitcoin Market: Trading Opportunities or Investors’ Pitfall?

```{r}
# 12-days EMA, 24-days EMA, 72-days EMA

bitcoin_date <- as.data.frame(bitcoin_price$date)
colnames(bitcoin_date) <- c("date")

bitcoin_ema <- list()
range_ema <- c(12,24,72)
for (i in seq_along(range_ema)){
  bitcoin_ema_v <- EMA(Cl(bitcoin_price),n=i)
  bitcoin_ema[[i]] <- bitcoin_ema_v
}

bitcoin_ema <- as.data.frame(do.call(cbind, bitcoin_ema)) 
names_ema <- c(paste0("ema_", range_ema)) %>% strsplit(split = " ")
colnames(bitcoin_ema) <- names_ema
ema <- bitcoin_date %>% cbind(bitcoin_ema)

# EMA: More weightage placed on recent price levels rather than past ones compared to using SMA
```

## **SMA**

```{r}
# 12-days SMA, 24-days SMA, 72-days SMA

bitcoin_sma <- list()
range_sma <- c(12,24,72)
for (i in seq_along(range_sma)){
  bitcoin_sma_v <- EMA(Cl(bitcoin_price),n=i)
  bitcoin_sma[[i]] <- bitcoin_sma_v
}

bitcoin_sma <- as.data.frame(do.call(cbind, bitcoin_sma)) 
names_sma <- c(paste0("ema_", range_sma)) %>% strsplit(split = " ")
colnames(bitcoin_sma) <- names_sma
sma <- bitcoin_date %>% cbind(bitcoin_sma)

```


## **Rate of Change**

The n value is how many periods ago the current price is being compared to. Smaller values will see the ROC react more quickly to price changes, but that can also mean more false signals. A larger value means the ROC will react slower, but the signals could be more meaningful when they occur.
Short-term trader traders typically use a smaller number while longer-term investors use a larger number.

```{r}
# Assumptions:
# short term: 14,28
# longer term: 90,180,200

bitcoin_roc <- list()
range_roc <- c(14,28,90,180,200)
for (i in seq_along(range_roc)){
  bitcoin_roc_v <- ROC(Cl(bitcoin_price),n=i)
  bitcoin_roc[[i]] <- bitcoin_roc_v
}

bitcoin_roc <- as.data.frame(do.call(cbind, bitcoin_roc)) 
names_roc <- c(paste0("roc_", range_roc)) %>% strsplit(split = " ")
colnames(bitcoin_roc) <- names_roc

bitcoin_roc <- bitcoin_date %>% cbind(bitcoin_roc)

```

## **On-Balance Volume**
On-balance volume and the accumulation/distribution line are similar in that they are both momentum indicators that use volume to predict the movement of “smart money”. 
```{r}
bitcoin_obv <- as.data.frame(OBV(bitcoin_price$close, bitcoin_price$volume_currency))
bitcoin_obv <- bitcoin_date %>% cbind(bitcoin_obv)
colnames(bitcoin_obv) <- c("date","on_balance_vol")

```

### **NVT Ratio**
NVT Ratio (Network Value to Transactions Ratio) is similar to the PE Ratio used in equity markets.

Similar to the price-to-earnings (PE) ratio used in equity charts, the NVT looks at whether BTC is undervalued or overvalued. The ratio represents current market capitalization via network value and the level of USD-based transaction volume over a 24-hour period.

High NVT can indicate high growth or that the price may have reached an unsustainable level, while low NVT can signal market opportunity. 

Using the bitcoin indicators data to do this calculation. It takes Bitcoin Market Capitalization/Bitcoin Estimated Transaction Volume USD
```{r}
# Data about bitcoin activity, transaction fees, and mining. 
print("Downloading bitcoin indicators.")
code_list <- list(c("BCHAIN/TOTBC", "Total Bitcoins"), 
                  c("BCHAIN/MKTCP", "Bitcoin Market Capitalization"), 
                  c("BCHAIN/NADDU", "Bitcoin Number of Unique Addresses Used"), 
                  c("BCHAIN/ETRAV", "Bitcoin Estimated Transaction Volume BTC"), 
                  c("BCHAIN/ETRVU", "Bitcoin Estimated Transaction Volume USD"), 
                  c("BCHAIN/TRVOU", "Bitcoin USD Exchange Trade Volume"), 
                  c("BCHAIN/NTRAN", "Bitcoin Number of Transactions"), 
                  c("BCHAIN/NTRAT", "Bitcoin Total Number of Transactions"), 
                  c("BCHAIN/NTREP", "Bitcoin Number of Transactions Excluding Popular Addresses"), 
                  c("BCHAIN/NTRBL", "Bitcoin Number of Tansaction per Block"), 
                  c("BCHAIN/ATRCT", "Bitcoin Median Transaction Confirmation Time"), 
                  c("BCHAIN/TRFEE", "Bitcoin Total Transaction Fees"), 
                  c("BCHAIN/TRFUS", "Bitcoin Total Transaction Fees USD"), 
                  c("BCHAIN/CPTRA", "Bitcoin Cost Per Transaction"), 
                  c("BCHAIN/CPTRV", "Bitcoin Cost % of Transaction Volume"), 
                  c("BCHAIN/BLCHS", "Bitcoin api.blockchain Size"), 
                  c("BCHAIN/AVBLS", "Bitcoin Average Block Size"), 
                  c("BCHAIN/TOUTV", "Bitcoin Total Output Volume"), 
                  c("BCHAIN/HRATE", "Bitcoin Hash Rate"), 
                  c("BCHAIN/MIREV", "Bitcoin Miners Revenue"), 
                  c("BCHAIN/BCDDE", "Bitcoin Days Destroyed"), 
                  c("BCHAIN/BCDDW", "Bitcoin Days Destroyed Minimum Age 1 Week"), 
                  c("BCHAIN/BCDDM", "Bitcoin Days Destroyed Minimum Age 1 Month"), 
                  c("BCHAIN/BCDDY", "Bitcoin Days Destroyed Minimum Age 1 Year") ,
                  c("BCHAIN/BCDDC", "Bitcoin Days Destroyed Cumulative"))

bitcoin_data <- tibble()
# bitcoin_data <- foreach(i=seq_along(code_list), .combine='bind_rows') %dopar% {quandl_tidy(code_list[[i]][1], code_list[[i]][2])}
for (i in seq_along(code_list)) { 
  print(str_c("Downloading data for ", code_list[[i]][1], "."))
  bitcoin_data <- bind_rows(bitcoin_data, 
                            quandl_tidy(code_list[[i]][1], code_list[[i]][2]))
}

```

```{r}
# Clean Bitcoin Indicators
bitcoin_data <- bitcoin_data %>% 
  select(date, value, code) %>% 
  spread(code, value)
colnames(bitcoin_data) <- make.names(colnames(bitcoin_data))

```

```{r}
# NVT
bitcoin_data$nvt <- bitcoin_data$BCHAIN.MKTCP/bitcoin_data$BCHAIN.ETRVU

```

## **Average True Range (ATR)**

* a common indicator designed to measure volatility
* neither indicates trend direction nor momentum --> so need other indicators to do that instead
* experiencing a high level of volatility has a higher ATR, and a low volatility stock has a lower
```{r}

atr <- ATR(bitcoin_price[,c("high","low","close")], n=14) #14-days moving average
atr <- bitcoin_date %>% cbind(atr)
atr <- select(atr,c(date,atr))

```
