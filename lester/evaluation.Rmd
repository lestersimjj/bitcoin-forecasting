---
title: "Evaluating Models"
author: "Lester Sim"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    number_sections: no
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: yes
      smooth_scroll: no
editor_options:
  chunk_output_type: console
---

# 1. Load Packages
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#",
  message = FALSE,
  warning = FALSE,
  cache = FALSE,
  fig.align = "center",
  class.source = 'white'
)

# Set knit directory to project directory
```

```{r}
library(tidyverse)  # Data manipulation
library(tidymodels) # Building machine learning workflows and models
library(Quandl) # Download datasets
library(tidyquant)  # Functions for collecting and analyzing financial data
library(timetk)  # Functions to visualize, wrangle, and feature engineer time series data for forecasting and machine learning prediction
library(xgboost) # Machine learning algos
library(vip) # For constructing variable importance plots
library(caret) # Confusion matrix
library(stacks) # Ensemble
```

# 1. Evaluating Models
Strategy 1: Buy and Hold  
Strategy 2: Using time series model - Prophet
Strategy 3: Using XGBoost Trees
Strategy 4: Using multiple models (ensemble)

# 2. Import predictions   
Import predictions on test data from different models
```{r}
# Time Series
# change to date format
prophet_predict <- read_csv("data/prophet_signals.csv") %>% 
  mutate(date = dmy(date))

# XGBoost
xgboost_predict <- read_csv("data/xgboost_signals.csv")

# Ensemble
ensemble_predict <- read_csv("data/ensemble_predict.csv")

```

# 3. Import Test Data
```{r}
# Read Data
bitcoin_price <- read_csv("data/bitcoin_price.csv")
# Cleaning
bitcoin_price[bitcoin_price == 0] <- NA
bitcoin_price <- bitcoin_price %>%
  map_df(na.locf)

# Defining Target
bitcoin_model <- bitcoin_price %>%
  select(date, open, close) %>% 
  tq_mutate(select = close,
            mutate_fun = periodReturn,
            period = 'daily',
            type = 'arithmetic',
            col_rename = 'future_return') %>%
  mutate(future_return_sign = as.factor(ifelse(future_return > 0, 1, 0))) %>% 
  # Shift up future_returns and sign by 1. Use today's data to predict tomorrow's returns.
  # future_returns indicates the returns if I buy at today's close and sell at tmrrw's close
  # each row represent today
  mutate_at(c("future_return", "future_return_sign"), lead)
bitcoin_model <- bitcoin_model[-nrow(bitcoin_model), ]
test <- bitcoin_model %>% 
  filter(between(date, as.Date("2020-07-01"), as.Date("2020-11-29")))

```

# 3. Buy and Hold Strategy
```{r}
# Base Model
# Combines all the assessment sets from the 12 splits from cross-validation resamples
base_model <- test %>% 
  mutate(return_buyhold = cumprod(1 + future_return),
         signal_buyhold = 1)

```

# 4. Function to compute returns
```{r}
# Function to compute returns. Returns a 1 column vector
# computeReturns <- function(base, predicted){
#   overall <- base %>% 
#     left_join(predicted, by="date") %>% 
#     mutate(trading_cost = abs(pred_signal - lag(pred_signal, n = 1, default = 0)) * 0.003,
#            return_model = cumprod(1 + future_return * pred_signal - trading_cost))
#   return(overall$return_model)
# }

calculate_returns = function(data) {
  df = data %>% 
  mutate(Returns.Shift.Up = lead(Future.Ret),
         Returns = Predicted_signal * Returns.Shift.Up,
         Cum.Returns = cumprod(1 + Returns)) %>%
  select(Cum.Returns)
  
  return(df)
}

```

# 5. Compute returns of models
```{r}

all_models <- base_model %>% 
  mutate(signal_prophet = prophet_predict$pred_signal,
         return_prophet = computeReturns(base_model, prophet_predict),
         signal_rf = rf_predict$pred_signal,
         return_rf = computeReturns(base_model, rf_predict))

rmarkdown::paged_table(all_models %>% head())
```

## 14.2 Visualisations
```{r}
# Plot predicted buy/sell signal on price data
# See differences between models
prophet_plot <- all_models %>% ggplot(aes(x = date, y = close, color = signal_prophet)) +
    geom_line() +
    theme_light()
rf_plot <- all_models %>% ggplot(aes(x = date, y = close, color = signal_rf)) +
    geom_line() +
    theme_light()
grid.arrange(prophet_plot, rf_plot, nrow = 1)
```

```{r}
# Comparing returns across strategies
all_models %>% 
  select(date, return_buyhold, return_prophet, return_rf) %>%
  gather(key = "strategy", value = "returns", -date) %>% 
  ggplot(aes(x=date, y = returns)) +
    geom_line(aes(color = strategy)) +
    theme_light()
```


## 14.3 Descriptive Statistics
### 14.3.1 Confusion Matrix
```{r}
# Confusion Matrix for Prohphet
print(confusionMatrix(factor(all_models$signal_prophet),
                factor(all_models$future_return_sign)))

# Confusion Matrix for Random Forest
print(confusionMatrix(factor(all_models$signal_rf),
                factor(all_models$future_return_sign)))
```

### 14.3.2 Overall Returns
```{r}
all_returns <- all_models %>% 
  select(date, return_buyhold, return_prophet, return_rf) %>%
  gather(key = "strategy", value = "returns", -date) %>% 
  group_by(strategy) %>% 
  summarise_all(last)

rmarkdown::paged_table(all_returns)
```

### 14.3.3 Mean Daily Returns and SD
```{r}
# Daily Returns
all_models_performance <- all_models %>% 
  select(date, future_return, signal_buyhold, signal_prophet, signal_rf) %>% 
  gather(key = "strategy", value = "daily_returns", -c(date, future_return)) %>% 
  mutate_at("daily_returns", ~.*future_return) %>% 
  group_by(strategy) %>% 
  summarise(d_ret = mean(daily_returns), d_sd = sd(daily_returns))

rmarkdown::paged_table(all_models_performance)
```

### 14.3.4 Annualised Returns and SD
```{r}
all_models_performance <- all_models_performance %>% 
  mutate(ann_ret = (1+d_ret)^365 - 1,
         ann_sd = d_sd * 365 ^ 0.5)
rmarkdown::paged_table(all_models_performance)
```

### 14.3.4 Sharpe Ratio
```{r}
all_models_performance <- all_models_performance %>% 
  # Minus risk-free rate. T-bills
  mutate(ann_sharpe = ann_ret-0.0011/ann_sd)

rmarkdown::paged_table(all_models_performance)
```

