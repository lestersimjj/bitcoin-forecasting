---
title: "Modelling with TidyModels"
author: "Lester Sim"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    number_sections: no
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: yes
      smooth_scroll: no
editor_options:
  chunk_output_type: console
---

# 1. Load Packages
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#",
  message = FALSE,
  warning = FALSE,
  cache = FALSE,
  fig.align = "center",
  class.source = 'white'
)

# Set knit directory to project directory
```

```{r}
library(tidyverse)  # Data manipulation
library(tidymodels) # Building machine learning workflows and models
library(Quandl) # Download datasets
library(tidyquant)  # Functions for collecting and analyzing financial data
library(timetk)  # Functions to visualize, wrangle, and feature engineer time series data for forecasting and machine learning prediction
library(xgboost) # Machine learning algos
library(vip) # For constructing variable importance plots
library(caret) # Confusion matrix
library(stacks) # Ensemble
```

# 14. Evaluating Models
Strategy 1: Buy and Hold  
Strategy 2: Using time series model - Prophet
Strategy 3: Using XGBoost Trees
Strategy 4: Using multiple models (ensemble)

## 14.1 Computing Returns from the Model.
```{r}
# Read predictions from the different models

```


```{r}
# Function to compute returns. Returns a 1 column vector
# predicted should be a 2 column df with columns date, pred_signal
# Assume 0.3% as trading cost
computeReturns <- function(base, predicted){
  overall <- base %>% 
    left_join(predicted, by="date") %>% 
    mutate(trading_cost = abs(pred_signal - lag(pred_signal, n = 1, default = 0)) * 0.003,
           return_model = cumprod(1 + future_return * pred_signal - trading_cost))
  return(overall$return_model)
}

# Base Model
# Combines all the assessment sets from the 12 splits from cross-validation resamples
base_model <- resamples_cv %>% 
  mutate(.testing = map(splits, testing)) %>% 
  select(id, .testing) %>% 
  unnest(.testing) %>% 
  arrange(date) %>% 
  select(date, close, future_return_sign, future_return) %>% 
  mutate(return_buyhold = cumprod(1 + future_return),
         signal_buyhold = 1)

# RF model
# Extract and merge predictions of individual fold test data
rf_predict <- rf_resampling %>%
  mutate(.assessment = map(splits, assessment)) %>%
  select(id, .predictions, .assessment) %>% 
  unnest(c(.predictions, .assessment), names_repair = "universal") %>% 
  rename(pred_signal = .pred_class) %>% 
  arrange(date) %>% 
  select(date, pred_signal) %>% 
  mutate_at("pred_signal", ~as.numeric(as.character(.)))  # Convert factor into num

# Time Series
prophet_predict <- read_csv("data/prophet_signals.csv") %>%
  filter(date < "2020-11-30") %>%
  rename("pred_signal" = "prophet_pred_signal") %>%
  select(-date)

all_models <- base_model %>% 
  mutate(signal_prophet = prophet_predict$pred_signal,
         return_prophet = computeReturns(base_model, prophet_predict),
         signal_rf = rf_predict$pred_signal,
         return_rf = computeReturns(base_model, rf_predict))

rmarkdown::paged_table(all_models %>% head())
```

## 14.2 Visualisations
```{r}
# Plot predicted buy/sell signal on price data
# See differences between models
prophet_plot <- all_models %>% ggplot(aes(x = date, y = close, color = signal_prophet)) +
    geom_line() +
    theme_light()
rf_plot <- all_models %>% ggplot(aes(x = date, y = close, color = signal_rf)) +
    geom_line() +
    theme_light()
grid.arrange(prophet_plot, rf_plot, nrow = 1)
```

```{r}
# Comparing returns across strategies
all_models %>% 
  select(date, return_buyhold, return_prophet, return_rf) %>%
  gather(key = "strategy", value = "returns", -date) %>% 
  ggplot(aes(x=date, y = returns)) +
    geom_line(aes(color = strategy)) +
    theme_light()
```


## 14.3 Descriptive Statistics
### 14.3.1 Confusion Matrix
```{r}
# Confusion Matrix for Prohphet
print(confusionMatrix(factor(all_models$signal_prophet),
                factor(all_models$future_return_sign)))

# Confusion Matrix for Random Forest
print(confusionMatrix(factor(all_models$signal_rf),
                factor(all_models$future_return_sign)))
```

### 14.3.2 Overall Returns
```{r}
all_returns <- all_models %>% 
  select(date, return_buyhold, return_prophet, return_rf) %>%
  gather(key = "strategy", value = "returns", -date) %>% 
  group_by(strategy) %>% 
  summarise_all(last)

rmarkdown::paged_table(all_returns)
```

### 14.3.3 Mean Daily Returns and SD
```{r}
# Daily Returns
all_models_performance <- all_models %>% 
  select(date, future_return, signal_buyhold, signal_prophet, signal_rf) %>% 
  gather(key = "strategy", value = "daily_returns", -c(date, future_return)) %>% 
  mutate_at("daily_returns", ~.*future_return) %>% 
  group_by(strategy) %>% 
  summarise(d_ret = mean(daily_returns), d_sd = sd(daily_returns))

rmarkdown::paged_table(all_models_performance)
```

### 14.3.4 Annualised Returns and SD
```{r}
all_models_performance <- all_models_performance %>% 
  mutate(ann_ret = (1+d_ret)^365 - 1,
         ann_sd = d_sd * 365 ^ 0.5)
rmarkdown::paged_table(all_models_performance)
```

### 14.3.4 Sharpe Ratio
```{r}
all_models_performance <- all_models_performance %>% 
  # Minus risk-free rate. T-bills
  mutate(ann_sharpe = ann_ret-0.0011/ann_sd)

rmarkdown::paged_table(all_models_performance)
```

