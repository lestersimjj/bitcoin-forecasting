---
title: "Evaluating Models"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    number_sections: no
    toc: yes
    toc_depth: 4
    toc_float:
      collapsed: yes
      smooth_scroll: no
editor_options:
  chunk_output_type: console
---

Load Packages
```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = FALSE,
  comment = "#",
  message = FALSE,
  warning = FALSE,
  cache = FALSE,
  fig.align = "center",
  class.source = 'white'
)

# Set knit directory to project directory
#knitr::opts_knit$set(root.dir = 'C:/Users/dylan/OneDrive/Documents/bitcoin-forecasting')
```

```{r}
library(tidyverse)  # Data manipulation
library(tidymodels) # Building machine learning workflows and models
library(tidyquant)  # Functions for collecting and analyzing financial data
library(timetk)  # Functions to visualize, wrangle, and feature engineer time series data for forecasting and machine learning prediction
library(xgboost) # Machine learning algos
library(vip) # For constructing variable importance plots
library(caret) # Confusion matrix
library(stacks) # Ensemble
```

# 1. Evaluating Models
In our previous files, we have built 3 different models for predicting when we should buy/sell bitcoin. We will introduce the buy-and-hold strategy to act as a benchmark performance for us. Here are the 4 models we will be evaluating:

Strategy 1: Buy and Hold  
Strategy 2: Using time series model - Prophet  
Strategy 3: Using XGBoost Trees  
Strategy 4: Using multiple models (ensemble)  

# 2. Import predictions   
Import predictions (on test data) from different models that we previously predicted 
```{r}
# Time Series
# change to date format
prophet_predict <- read_csv("data/prophet_signals.csv") %>% 
  mutate(date = as.Date(date, format="%d/%m/%y"))

# XGBoost
xgb_predict <- read_csv("data/xgboost_signals.csv")

# Ensemble
ensemble_predict <- read_csv("data/ensemble_predict_updated_3am.csv") %>% 
  mutate(date = as.Date(date, format="%d/%m/%y")) %>%
  select(-X1)

```

# 3. Import Test Data
```{r}
# Read Data
bitcoin_price <- read_csv("data/bitcoin_price.csv")
# Cleaning
bitcoin_price[bitcoin_price == 0] <- NA
bitcoin_price <- bitcoin_price %>%
  map_df(na.locf)

# Defining Target
bitcoin_model <- bitcoin_price %>%
  select(date, open, close) %>% 
  tq_mutate(select = close,
            mutate_fun = periodReturn,
            period = 'daily',
            type = 'arithmetic',
            col_rename = 'future_return') %>%
  mutate(future_return_sign = as.factor(ifelse(future_return > 0, 1, 0))) %>% 
  # Shift up future_returns and sign by 1. Use today's data to predict tomorrow's returns.
  # future_returns indicates the returns if I buy at today's close and sell at tmrrw's close
  # each row represent today
  mutate_at(c("future_return", "future_return_sign"), lead)
bitcoin_model <- bitcoin_model[-nrow(bitcoin_model), ]
test <- bitcoin_model %>% 
  filter(between(date, as.Date("2020-07-01"), as.Date("2020-11-29")))

```

# 3. Buy and Hold Strategy  
Buy at the beginning and sell only towards the end
```{r}
# Base Model
# Combines all the assessment sets from the 12 splits from cross-validation resamples
base_model <- test %>% 
  mutate(return_buyhold = cumprod(1 + future_return),
         signal_buyhold = 1)

```

# 4. Function to compute returns
```{r}
# Function to compute returns. Returns a 1 column returns vector
# computeReturns = function(base, data) {
#   df = base %>%
#     left_join(data, by="date") %>%
#     mutate(Returns.Shift.Up = lead(future_return, default = 0),
#          Returns = pred_class * Returns.Shift.Up,
#          Cum.Returns = cumprod(1 + Returns)) %>%
#     select(Cum.Returns)
# 
#   return(df$Cum.Returns)
# }

computeReturns <- function(base, predicted){
  overall <- base %>%
    left_join(predicted, by="date") %>%
    mutate(trading_cost = abs(pred_class - lag(pred_class, n = 1, default = 0)) * 0.003,
           return_model = cumprod(1 + future_return * pred_class - trading_cost))

  return(overall$return_model)
}

```

# 5. Compute returns of each model  
```{r}
# Compute returns for all models and cbind them together
all_models <- base_model %>% 
  mutate(signal_prophet = prophet_predict$pred_class,
         return_prophet = computeReturns(base_model, prophet_predict),
         signal_xgb = xgb_predict$pred_class,
         return_xgb = computeReturns(base_model, xgb_predict),
         signal_ensemble = ensemble_predict$pred_class,
         return_ensemble = computeReturns(base_model, ensemble_predict))

rmarkdown::paged_table(all_models %>% head())
```

## 6. Visualisations for buy/sell signal generated by the different models
```{r}
# Plot predicted buy/sell signal on price data
# Plot for Prophet
all_models %>% ggplot(aes(x = date, y = close, color = signal_prophet)) +
    geom_line() +
    theme_light()
```

```{r}
# Plot for xgb
all_models %>% ggplot(aes(x = date, y = close, color = signal_xgb)) +
    geom_line() +
    theme_light()
```

```{r}
# Plot for ensemble
all_models %>% ggplot(aes(x = date, y = close, color = signal_ensemble)) +
    geom_line() +
    theme_light()
```

# 7. Comparing returns across different models
Plotting the various returns of the different strategies (predicted on test date), we are able to see that the ensemble model has the best returns, followed by the buy-and-hold strategy, XGBoost and Time-Series (Prophet).

The advantage of the ensemble model helps to exploit the strengths of each model. By regressing on the predicted probabilities across all the models, we can put more weight on models that have better predictions, but have other models be stronger in areas where a certain model could be weaker.

```{r}
all_models %>% 
  select(date, return_buyhold, return_prophet, return_xgb, return_ensemble) %>%
  gather(key = "strategy", value = "returns", -date) %>% 
  ggplot(aes(x=date, y = returns)) +
    geom_line(aes(color = strategy)) +
    theme_light()
```


# 8. Descriptive Statistics
## 8.1 Confusion Matrix
The ensemble model was able to produce the highest accuracy at 82% compared to the other models. The high accuracy of the ensemble model would perhaps explain the higher returns as the model predicts the best time to buy/sell bitcoins as compared to a buy-and-hold strategy.
```{r}
# Confusion Matrix for Prohphet
print(confusionMatrix(factor(all_models$signal_prophet),
                factor(all_models$future_return_sign)))

# Confusion Matrix for XGBoost
print(confusionMatrix(factor(all_models$signal_xgb),
                factor(all_models$future_return_sign)))

# Confusion Matrix for Ensemble
print(confusionMatrix(factor(all_models$signal_ensemble),
                factor(all_models$future_return_sign)))
```

## 8.2 Overall Returns
Buy and hold strategy still generates the highest returns. This is probably because of the recent spike in prices due to the large inflow of funds into cryptocurrency by institutions (eg. Paypal, Robinhood).  
```{r}
all_returns <- all_models %>% 
  select(date, return_buyhold, return_prophet, return_xgb, return_ensemble) %>%
  gather(key = "strategy", value = "returns", -date) %>% 
  group_by(strategy) %>% 
  summarise_all(last)

rmarkdown::paged_table(all_returns)
```

## 8.3 Mean Daily Returns and SD
```{r}
# Daily Returns
all_models_performance <- all_models %>% 
  select(date, future_return, signal_buyhold, signal_prophet, signal_xgb, signal_ensemble) %>% 
  gather(key = "strategy", value = "daily_returns", -c(date, future_return)) %>% 
  mutate_at("daily_returns", ~.*future_return) %>% 
  group_by(strategy) %>% 
  summarise(d_ret = mean(daily_returns), d_sd = sd(daily_returns))

rmarkdown::paged_table(all_models_performance)
```

## 8.4 Annualised Returns and SD
```{r}
all_models_performance <- all_models_performance %>% 
  mutate(ann_ret = (1+d_ret)^365 - 1,
         ann_sd = d_sd * 365 ^ 0.5)

rmarkdown::paged_table(all_models_performance)
```

## 8.5 Sharpe Ratio
```{r}
all_models_performance <- all_models_performance %>% 
  # Minus risk-free rate. T-bills
  mutate(ann_sharpe = ann_ret-0.0011/ann_sd)

rmarkdown::paged_table(all_models_performance)
```

